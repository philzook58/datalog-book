<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Datalog Comin&#x27; Right At Ya!</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="negation.html"><strong aria-hidden="true">2.</strong> Negation</a></li><li class="chapter-item expanded "><a href="adt.html"><strong aria-hidden="true">3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="seminaive.html"><strong aria-hidden="true">4.</strong> Semi-naive Evaluation</a></li><li class="chapter-item expanded affix "><li class="part-title">Applications</li><li class="chapter-item expanded "><a href="analysis.html"><strong aria-hidden="true">5.</strong> Program Analysis</a></li><li class="chapter-item expanded "><a href="lattices.html"><strong aria-hidden="true">6.</strong> Aggregates, Lattices, and Subsumption</a></li><li class="chapter-item expanded "><a href="logic.html"><strong aria-hidden="true">7.</strong> Logic Programs and Magic Set</a></li><li class="chapter-item expanded "><a href="imperative.html"><strong aria-hidden="true">8.</strong> Imperative Programs</a></li><li class="chapter-item expanded "><a href="functional.html"><strong aria-hidden="true">9.</strong> Functional Programs</a></li><li class="chapter-item expanded "><a href="graphs.html"><strong aria-hidden="true">10.</strong> Graphs</a></li><li class="chapter-item expanded affix "><li class="part-title">Egglog</li><li class="chapter-item expanded "><a href="egglog.html"><strong aria-hidden="true">11.</strong> Egglog</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><a href="sql.html"><strong aria-hidden="true">12.</strong> SQL</a></li><li class="chapter-item expanded "><a href="implementations.html"><strong aria-hidden="true">13.</strong> Implementations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Datalog Comin&#x27; Right At Ya!</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Well, hey there buddo!</p>
<p>This book is intended to be an introduction to the programming language datalog. There isn't an overwhelming number of resources out there about datalog and some never get past queries over movie or employee databases. Datalog really is a programming language.</p>
<p>Datalog is fascinating from multiple perspectives.</p>
<ul>
<li>Operational - Datalog rules have a simple model of execution</li>
<li>Relational - Datalog is a declarative description language of relations</li>
<li>Logical - Datalog rules can be read as logical axioms</li>
</ul>
<p>There is a thrill that comes from finding out how to program a system that does not offer the typical programming constructs. Some other restrictive or unusual systems might include regular expressions, sql, apl, forth, vectorized arrays, SIMD operations, assembly, typelevel programming, or weird machines. From these restrictions come great pains but also great gains. Datalog by is highly parallelizable and has execution strategies that avoid large redundant calculations you might naively make.</p>
<p>This book is built around the syntax of the implementation <a href="https://souffle-lang.github.io/">Souffle Datalog</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>To get started, let's demonstrate the core constructs of Datalog.</p>
<p>In Souffle Datalog, tables are declared alongside the types and names of their columns. This is the analog of a <code>CREATE</code> statement in SQL. The names of the columns are not used except for printing in Souffle.</p>
<p>Souffle Datalog has a number of basic built in types</p>
<ul>
<li><code>symbol</code> is effectively a string datatype</li>
<li><code>number</code> is signed integers</li>
<li><code>unsigned</code> is unsigned integers</li>
<li><code>float</code> are floating point numbers</li>
</ul>
<p>Here's an example declaration</p>
<pre><code class="language-souffle">.decl sausages(maker : symbol, difference : number, count : unsigned, inches : float)
</code></pre>
<h2 id="facts"><a class="header" href="#facts">Facts</a></h2>
<p>Facts are inserted into the database by &quot;calling&quot; the table with values for the columnsc followed by a period. 
This is the analog of a <code>INSERT INTO mytable FROM VALUES (&quot;42&quot;,-42,42,42.1);</code> statement in SQL.</p>
<p>Tables in Souffle datalog have set semantics, meaning duplicate rows are coalesced into a single row.</p>
<p>The user only sees relations marked as <code>.output</code>.</p>
<pre><code class="language-souffle editable">.decl mytable(x : symbol, y : number, z : unsigned, w : float)
mytable(&quot;42&quot;, -42, 42, 42.1).
mytable(&quot;42&quot;, -42, 42, 42.1). // Duplicate rows are coalesced
mytable(&quot;Hi&quot;, -47, 7331, 11.1).
.output mytable(IO=stdout)

.decl this_table_wont_print(x : symbol)
this_table_wont_print(&quot;hidden&quot;).
</code></pre>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>The simplistic syntax for insertion of facts is nice, but datalog rules are where it shines.</p>
<p>Rules describe how new facts can be derived from the already known database of facts. Sometimes the initial facts are called the intensional database (IDB) and the derived facts are called the extensional database (EDB).</p>
<p>They have a right hand side know as a clause which corresponds roughly to a <code>SELECT</code> query and left hand side known as a head which corresponds to an <code>INSERT</code>. Facts can be seen as a rule with an empty unconditional body.</p>
<p>An SQL style query can be encoded by making a rule whose body corresponds to the query and saves the result to a table in the head.</p>
<pre><code class="language-souffle">.decl foo(x : symbol, y : symbol)
foo(&quot;a&quot;,&quot;a&quot;).
foo(&quot;b&quot;,&quot;a&quot;).

.decl myquery(x : symbol)
myquery(a) :- foo(x,x). 
.output myquery(IO=stdout)
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Ok, rules are great, but what is <em>really</em> great are recursive rules.</p>
<p>There is something to be said about examples involving family. This is a concept we primally understand (hence the popularity of the Fast and Furious franchise).</p>
<p>We can use rules to extract grandparent, greatgrandparent, and greatgreatgrandparent tables from parent tables.</p>
<pre><code>grandparent(a,c) :- parent(a,b), parent(b,c).
greatgrandparent(a,c) :- parent(a,b), grandparent(b,c).
greatgreatgrandparent(a,c) :- parent(a,b), greatgrandparent(b,c).
</code></pre>
<p>There is a theme here, a pattern to extract. Any person deep in our family tree is our ancestor. To describe this concept, we can use a recursive rule. Our parent is our ancestor, and the parent of our ancestor is also an ancestor.</p>
<pre><code>ancestor(a,b) :- parent(a,b).
ancestor(a,c) :- parent(a,b), ancestor(b,c).
</code></pre>
<p>We can also count how deep a relationship is.</p>
<pre><code>ancestor(1, a, b) :- parent(a,b).
ancestor(n+1, a,c) :- parent(a,b), ancestor(n,b,c).
</code></pre>
<p>Your ancestors should form a tree structure. If they form a DAG, that's kind of messed up.</p>
<p>If your ancestor relationship has <em>cycles</em> in it, that is deeply troubling as a human. But datalog will be happy as a clam!</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://www.stephendiehl.com/posts/exotic04.html">Exotic Programming Ideas: Part 4 (Datalog) - Stephen Diehl</a></li>
<li><a href="https://souffle-lang.github.io/tutorial">Souffle Datalog tutorial</a></li>
</ul>
<pre><code class="language-souffle editable">.decl edge(x : number, y : number)
edge(1,2).
.output edge(IO=stdout)
</code></pre>
<p>Hey</p>
<p>Suggestions:
Easy Sudoku
matrix logic puzzles.
first cousins</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="negation"><a class="header" href="#negation">Negation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<p>Algebraic data types are a programming language feature that are very useful for describing tree-like structures.</p>
<pre><code class="language-souffle">.type IntList = Nil {} | Cons {hd : number, tl : IntList}
.type BinTree = Empty {} | Leaf {n : number} | Node {left : BinTree, right : BinTree}

</code></pre>
<p>Traditional datalog does not include algebraic datatypes. Algebraic datatypes completely destroy the termination guarantees of datalog.</p>
<pre><code class="language-souffle">.type Nat = Succ {prev : Nat} | Zero {}

.decl nats(n : Nat)
nats($Zero()).
nats($Succ(n)) :- nats(n).
.limitsize nats(n=10)
.output nats(IO=stdout)
</code></pre>
<p>Despite that, they are profoundly useful.</p>
<h2 id="subterm-predicates"><a class="header" href="#subterm-predicates">Subterm predicates</a></h2>
<p>A useful predicate is one that collects up all subterms. You can use this for example to determine which lists to compute the length of. Without this blocking predicate, datalog would compute the length of all lists, which is not what you want.</p>
<pre><code class="language-souffle">.type IntList = Nil {} | Cons {hd : number, tl : IntList}
.type BinTree = Empty {} | Leaf {n : number} | Node {left : BinTree, right : BinTree}

.decl list(l : IntList)
list(tl) :- list($Cons(_hd,tl)).
.decl bintree(b : BinTree)
bintree(left), bintree(right) :- bintree($Node(left,right)).

.decl length(l : IntList, n : unsigned)
length($Nil(), 0).
length(l, n + 1) :- list(l), l = $Cons(_hd,tl), length(tl, n).

list($Cons(3,$Cons(2,$Cons(1,$Nil())))).
.output length(IO=stdout)
</code></pre>
<h2 id="autoinc-and-skolemization"><a class="header" href="#autoinc-and-skolemization">Autoinc and Skolemization</a></h2>
<p>It is very tempting and operationally simple to use the <code>autoinc()</code> feature, which maintains a mutable counter that increments by one every time you call it. This is really problematic with regards to the declarative semantics of datalog. You get different results depending on the order and how many times you execute rules.</p>
<p>It is almost universally better to </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semi-naive-evaluation"><a class="header" href="#semi-naive-evaluation">Semi-naive Evaluation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-analysis"><a class="header" href="#program-analysis">Program Analysis</a></h1>
<h2 id="pure-expressions"><a class="header" href="#pure-expressions">Pure Expressions</a></h2>
<h3 id="huttons-razor"><a class="header" href="#huttons-razor">Hutton's Razor</a></h3>
<p>There is a very solid rule thumb called Hutton's razor that you should try out programming language techqniues on a simple language of only addition and constants first. You can learn a lot.</p>
<p>The first thing to do with such expressions is of course to evaluate them.</p>
<pre><code class="language-souffle">.type AExpr = Add {x : AExpr, y : AExpr} | Lit {n : number}

.decl aexpr(e : AExpr)
aexpr(x), aexpr(y) :- aexpr($Add(x,y)).

.decl eval(e : AExpr, v : number)
eval(e, vx + vy) :- aexpr(e), e = $Add(x,y), eval(x,vx), eval(y,vy).
eval(e, n) :- aexpr(e), e = $Lit(n).

aexpr($Add($Add($Lit(1), $Lit(2)), $Lit(3))).
.output eval(IO=stdout)
</code></pre>
<h3 id="adding-variables"><a class="header" href="#adding-variables">Adding Variables</a></h3>
<p>One direction extend the language to make it more interesting is to add variables. Nothing needs to change, but now eval becomes a partial relation, only filled in for subterms that do not contain the variables. <code>eval</code> now has the flavor of a constant propagation analysis. By using the results of the analysis, we can simplify the original expressions. Since <code>eval</code> does not depend on <code>simplify</code>, we can check whether or not an entry in <code>eval</code> exists for <code>e</code> using negation.</p>
<pre><code class="language-souffle">.type AExpr = Add {x : AExpr, y : AExpr} | Lit {n : number} | Var {v : symbol}

.decl aexpr(e : AExpr)
aexpr(x), aexpr(y) :- aexpr($Add(x,y)).

.decl eval(e : AExpr, v : number)
eval(e, vx + vy) :- aexpr(e), e = $Add(x,y), eval(x,vx), eval(y,vy).
eval(e, n) :- aexpr(e), e = $Lit(n).

.decl simplify(orig : AExpr, simp : AExpr)
simplify(e,$Lit(v)) :- eval(e, v).
simplify(e,e) :- aexpr(e), !eval(e, _), e = $Var(x).
simplify(e,$Add(x1,y1)) :- aexpr(e), !eval(e, _), e = $Add(x,y), simplify(x,x1), simplify(y,y1).

aexpr($Add($Add($Lit(1), $Lit(2)), $Var(&quot;x&quot;))).
.output simplify(IO=stdout)
</code></pre>
<h3 id="evaluation-in-environments"><a class="header" href="#evaluation-in-environments">Evaluation in Environments</a></h3>
<p>We can also evaluate the language in an environment. I'm going to change my representation of terms only allow 3 named variables. This is to avoid needing first class maps from symbols to numbers to represent the environment (which is doable but complicated by accident in Souffle datalog. Other datalogs support this more easily.). Instead we can use a fixed sized record to represent the environment.</p>
<pre><code class="language-souffle">.type AExpr = Add {x : AExpr, y : AExpr} | Lit {n : number} | X {} | Y {} | Z {}
.type Env = [x : number, y : number, z : number]

.decl aexpr(e : AExpr)
aexpr(x), aexpr(y) :- aexpr($Add(x,y)).

.decl env(e : Env)

.decl eval(e : AExpr, rho : Env, v : number)
eval(e, rho, vx + vy) :- aexpr(e), e = $Add(x,y), eval(x,rho,vx), eval(y,rho,vy).
eval(e, rho, n) :- env(rho), aexpr(e), e = $Lit(n).
eval($X(),rho,x) :- env(rho), rho = [x,_y,_z].
eval($Y(),rho,y) :- env(rho), rho = [_x,y,_z].
eval($Z(),rho,z) :- env(rho), rho = [_x,_y,z].

aexpr($Add($Add($Lit(1), $Lit(2)), $X())).
env([1,2,3]).
.output eval(IO=stdout)
</code></pre>
<p>Now let us constrast this with a different approach of describing states which might have been your first inclination.</p>
<pre><code>.type AExpr = Add {x : AExpr, y : AExpr} | Lit {n : number} | Var {x : symbol}

.decl aexpr(e : AExpr)
aexpr(x), aexpr(y) :- aexpr($Add(x,y)).

.decl env(x : symbol, v : number)


</code></pre>
<p>Another thing we can do in this simple language is a valueset analysis. Given the set of possible values</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates-lattices-and-subsumptions"><a class="header" href="#aggregates-lattices-and-subsumptions">Aggregates, Lattices, and Subsumptions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logic-programs-and-magic-set"><a class="header" href="#logic-programs-and-magic-set">Logic Programs and Magic Set</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imperative-programs"><a class="header" href="#imperative-programs">Imperative Programs</a></h1>
<p>Imperative programs proceed via a manipulation of state.</p>
<p>In essence, a stateful program can be emulated in datalog by recursively transforming one state to the next.</p>
<pre><code>state(x,y,z) :- state(x,y,z).
</code></pre>
<p>It is desirable from a modelling perspective to separate out a notion of position in the program as special. Example of position include the state in a state machine, the program counter in assembly, or the statement label in a typical imperative program.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programs"><a class="header" href="#functional-programs">Functional Programs</a></h1>
<p>There are two issues to tackle when converting functional programs to datalog.</p>
<ol>
<li>Datalog deals mostly in relations not functions.</li>
<li>Datalog is bottom up, whereas functional programs are demand driven (they only compute functions that are called).</li>
</ol>
<p>Functional programs can be converted to logic programs by making the return value a parameter to the relation. A function is a subcase of relations in which the last column is determined by the initial columns.</p>
<p>For example, the function <code>factorial(n)</code> becomes the relation <code>factorial(n,res)</code> or <code>append(x,y)</code> becomes <code>append(x,y,res)</code>.</p>
<pre><code class="language-souffle">.decl factorial(n : unsigned, res : unsigned)
factorial(0,1).
factorial(1,1).
factorial(n+1, (n + 1) * m) :- factorial(n, m), n &lt; 10.
.output factorial(IO=stdout)
</code></pre>
<p>A priori I have chosen to stop the process at <code>n = 10</code>. This is fine if we can know at compile time what answers we need computed. What if we don't though? Then we need to write the function in a demand driven style.</p>
<h2 id="demand"><a class="header" href="#demand">Demand</a></h2>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>In the actual implementation of a functional program, there exists some data structure to keep track of who needs what results and what to do with them next. This is typically achieved via a stack, which records return addresses and records the needed state of the call site.</p>
<p>The stack is an implicit data structure that most languages maintain for you, but it is useful to note sometime that it is there.</p>
<p>This same observation is useful in other programming contexts. It is sometimes relatively wasteful to use the general purpose function call mechanism. You can convert a recursive function call into a loop and maintain that analog of your own stack for efficiency purposes.</p>
<p>Datalog does not have an implicit stack. If you want such a thing, you must build it.</p>
<h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Souffle datalog by default offers C preprocesor macros. These are useful for defining simple functions.</p>
<h1 id="inline-relations"><a class="header" href="#inline-relations">Inline relations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egglog"><a class="header" href="#egglog">Egglog</a></h1>
<pre><code class="language-scheme editable runnable">
; edit me
(datatype Expr (Lit i64) (Add Expr Expr))
(rewrite (Add (Lit i) (Lit j)) (Lit (+ i j)))
(relation expr (Expr))
(expr (Add (Lit 1) (Lit 2)))
(run 10)
(print expr)

</code></pre>
<h1 id="egglog-by-example"><a class="header" href="#egglog-by-example">Egglog by Example</a></h1>
<p>(Copied From Pearls Section of paper submission)</p>
<p>In this section, we will walk through a list of examples
showing the wide applications of egglog.</p>
<h2 id="functional-programming-with-egglog"><a class="header" href="#functional-programming-with-egglog">Functional Programming with Egglog</a></h2>
<p>Egglog is capable of evaluating many functional programs very naturally.
The standard evaluation of Datalog programs is traditionally done bottom up.
Starting from the facts known,
it iteratively derives new facts,
and when it terminates,
all the derivable facts
are contained in the database.
In the evaluation of functional programs,
however,
we usually start with the goal of evaluating a big expression and
break it down into smaller goals while
traversing the abstract syntax tree from root to leaves,
before collecting the results bottom up.
In order to simulate the top-down style of evaluation
of functional programs,
Datalog programmers need to create manual ``demand'' relations
that carefully tune the firing of rules
to capture the evaluation order of functional programs.
On the other hand,
egglog express many functional programs very naturally,
thanks to the unification mechanism.</p>
<p>For example, consider the task of computing the relation <code>tree_size</code>,
which maps trees to their sizes.
A full instantiation of the <code>tree_size</code> finds the size of <em>all</em> trees
and therefore is infinite,
so bottom-up evaluations will not terminate
in languages like Souffle.
We need to manually <em>demand transform</em> the program
to make sure we only instantiate <code>tree_size</code>
for the trees asked for and their children.
Demand transformation first populates a &quot;demand&quot; relation,
and <code>tree_size</code> will compute only trees that resides in the demand relation.
The program is shown below.
To get the size of a specific tree,
we have to first insert the tree object into the <code>tree_size_demand</code>
relation to make a demand, before looking up <code>tree_size</code> for
the actual tree size.</p>
<pre><code class="language-souffle"> .type Tree = Leaf {} | Node {t1: Tree, t2: Tree}
 .decl tree_size_demand(l: Tree)
 .decl tree_size(t: Tree, res: number)
 // populate demands from roots to leaves
 tree_size_demand(t1) :-
     tree_size_demand($Node(t1, t2)).
 tree_size_demand(t2) :-
     tree_size_demand($Node(t1, t2)).
 // calculate bottom-up
 tree_size($Node(t1, t2), s1 + s2) :-
     tree_size_demand($Node(t1, t2)),
     tree_size(t1, s1),
     tree_size(t2, s2).
 tree_size($Leaf(), 1).
 // compute size for a particular tree
 tree_size_demand($Node($Leaf(), $Leaf())).
 .output tree_size

</code></pre>
<p>Similar to Datalog, Egglog programs are evaluated bottom up.
However, we do not need a separate demand relation in Egglog,
because we can use ids
to represent unknown or symbolic information.
To query the size of a tree   <code>t</code>,
we simply put the atom <code>(tree_size t)</code> in the action.
egglog will create a fresh id as a placeholder for the value
<code>tree_size</code> maps to on <code>t</code>,
and the rest of the rules will
figure out the actual size subsequently.
The egglog program is shown below.</p>
<pre><code class="language-scheme"> (datatype Tree (Leaf) (Node Tree Tree))
 (datatype Expr (Add Expr Expr) (Num i64))
 (function tree_size (Tree) Expr)
 ;; compute tree size symbolically
 (rewrite (tree_size (Node t1 t2))
     (Add (tree_size t1) (tree_size t2)))
 ;; evaluate the symbolic expression
 (rewrite (Add (Num n) (Num m))
     (Num (+ n m)))
 (union (tree_size (Leaf)) (Num 1))
 ;; compute size for a particular tree
 (define two (tree_size (Node (Leaf) (Leaf))))
  (run 10)
  (check (= two (Num 2)))
  (clear)
</code></pre>
<p>Conceptually, we create a ``hole'' for the value
<code>(tree_size t)</code> is mapped to.
A series of rewriting will ultimately fill in this hole
with concrete numbers.
We use fresh ids here in a way that is similar to
how logic programming languages use logic variables.
In logic programming,
logic variables represent unknown information
that has yet to be resolved.
We view this ability to represent the unknown
as one of the key insights
to both Egglog and logic programming languages
like Prolog and miniKanren.
However, unlike Prolog and miniKanren,
egglog does not allow backtracking
in favor of monotonicity and efficient evaluations.</p>
<h2 id="simply-typed-lambda-calculus"><a class="header" href="#simply-typed-lambda-calculus">Simply Typed Lambda Calculus</a></h2>
<p>% \yz{Consider removing the part on capture-avoiding substitutions}</p>
<p>Previous equality saturation applications use lambda calculus
as their intermediate representation for program rewriting
~\citep{koehler2021sketch,egg,storel}.
To manipulate lambda expressions in \egraphs, a key challenge is
performing capture-avoiding substitutions,
which requires tracking the set of free variables.
A traditional equality saturation framework will represent
the set of free variables
as an eclass analysis
and uses a user-defined applier to perform the capture-avoiding substitution,
both written in the host language (e.g., Rust).
As a result,
users need to reason about both rewrite rules and custom Rust code
to reason about their applications.</p>
<p>We follow the <code>lambda</code> test suite of egg \citep{egg}
and replicate the lambda calculus example in egglog.
Instead of writing custom Rust code for analyses,
we track the set of free variables using standard egglog rules.
Figure \ref{fig:free-var} defines a function that maps terms to set of variable names.
Since the set of free variables can shrink in equality saturation
(e.g., rewriting \(x-x\) to \(0\) can shrink the set of free variables from \({x}\) to the empty set),
we define the merge expression as set intersections.
The first two rules say that values have no free variables and variables have themselves
as the only free variable.
The free variables of lambda abstractions, let-bindings, and function applications are
inductively defined by constructing the appropriate variable sets at the right hand side.
Finally,
the last three rewrite rules perform the capture-avoiding substitution
over the original terms depending on the set of free variables.
When the variable of lambda abstraction is contained in the set of free variables
of the substituting term,
a new fresh variable name is needed.
We skolemize the rewrite rule
so that the new variable name is generated deterministically.
Note that the last two rules depend both positively and negatively
on whether the set of free variables contains a certain variable,
so this program is not monotonic in general.</p>
<p>% Some applications perform constant folding over
%  lambda expressions.
% For these applications, users have to write a composite analysis that is the Cartesian product of
%  constant folding analysis and free variable analysis.
% Each component of the composite analysis cannot propagate independently.
% In contrast, users can specify two individual analyses in egglog
%  by defining two functions or relations, and each individual analysis can propagate independently.</p>
<p>egglog can not only express eclass analyses,
which are typically written in a host language like Rust,
but also semantic analyses not easily expressible in eclass analyses.
For example, consider an equality saturation application
that optimizes matrix computation graphs and uses lambda calculus
as the intermediate representation.
Users may want to extract terms with the least cost as the outputs of optimizations,
but a precise cost estimator may depend on the type and shape information of an expression
(e.g., the dimensions of matrices being multiplied).
Expressing type inference within the abstraction of eclass analyses is difficult:
in eclass analyses, the analysis values are propagated bottom up,
from children to parent eclasses.
However, in simply typed lambda calculus,
the same term may have different types depending on the typing context,
so it is impossible to know the type of a term without first knowing the typing context.
Because the typing contexts need to be propagated top down first,
eclass analysis is not the right abstraction for type inference.
In contrast,
we can do type inference in egglog
by simply encoding the typing rule for simply typed lambda calculus in a Datalog style:
we first break down larger type inference goals into smaller ones,
propagate demand together with the typing context top down,
and assemble parent terms' types based on the children terms' bottom up.</p>
<p>\autoref{fig:stlc} shows a subset of rules that perform type inference
over simply typed lambda calculus.
We determine the types of variables based on contexts.
For lambda expressions, we rewrite the type of <code>(Lam x t1 e)</code>
to be \(t_1\rightarrow t_2\), where \(t_2\) is the type of \(e\) in the new context
where $x$ has type \(t_1\) (i.e., <code>(typeof (Cons x t1 ctx) e)</code>).
Finally, because we cannot directly rewrite the type of function applications
in terms of types of their subexpressions,
we explicitly populate demands for subexpressions and
derive the types of function applications using
the types of subexpressions once they are computed.</p>
<pre><code class="language-scheme">(function free (Term) (Set Ident)
    :merge (set-intersect old new))

;; Computing the set of free variables
(rule ((= e (Val v)))
      ((set (free e) (empty))))
(rule ((= e (Var v)))
      ((set (free e) (set-singleton v))))
(rule ((= e (Lam var body))
       (= (free body) fv))
      ((set (free e) (set-remove fv var))))
(rule ((= e (Let var e1 e2))
       (= (free e1) fv1) (= (free e2) fv2))
      ((set (free e) (set-union fv2
          (set-remove fv1 var)))))
(rule ((= e (App e1 e2))
       (= (free e1) fv1) (= (free e2) fv2))
      ((set (free e) (set-union fv1 fv2))))

;; [e2/v1](*$\lambda$*)v1.e1 rewrites to (*$\lambda$*)v1.e1
(rewrite (subst v e2 (Lam v e1))
         (Lam v body))
;; [e2/v2](*$\lambda$*)v1.e1 rewrites to (*$\lambda$*)v1.[e/v2]e1
;; if v1 is not in free(e2)
(rewrite (subst v2 e2 (Lam v1 e1))
         (Lam v1 (subst v2 e2 e1))
    :when ((!= v1 v2)
           (set-not-contains (free e2) v1)))
;; [e2/v2](*$\lambda$*)v1.e1 rewrites to (*$\lambda$*)v3.[e/v2][v3/v1]e1
;; for fresh v3 if v1 is in free(e2)
(rule ((= expr (subst v2 e2 (Lam v1 e1)))
       (!= v1 v2)
       (set-contains (free e2) v1))
      ((define v3 (Skolemize expr))
       (union expr (Lam v3 (subst v2 e2
           (subst v1 (Var v3) e1))))))
</code></pre>
<p>\caption{Free variable analysis
and capture avoiding substitution in egglog.
We use skolemization function \lstinline{Skolemize}
to deterministically generate fresh variables
for capture-avoiding substitution.
}</p>
<pre><code class="language-scheme">(function typeof (Ctx Expr) Type)

(function lookup (Ctx Ident) Type)
(rewrite (lookup (Cons x t ctx) x) t)
(rewrite (lookup (Cons y t ctx) x)
         (lookup ctx x)
    :when ((!= x y)))

;; Type of matrix constants
(rewrite (typeof ctx (fill (Num n) (Num m) val))
         (TMat n m))

;; Type of variables
(rewrite (typeof ctx (Var x) )
         (lookup ctx x))

;; Type of lambda abstractions
(rewrite (typeof ctx (Lam x t1 e))
         (Arr t1 (typeof (Cons x t1 ctx) e)))

;; Populate type inference demand for
;; subexpressions of function application
(rule ((= (typeof ctx (App f e)) t2))
      ((typeof ctx f)
       (typeof ctx e)))

;; Type of function application
(rule ((= (typeof ctx (App f e)) t)
       (= (typeof ctx f) (Arr t1 t2))
       (= (typeof ctx e) t2))
      ((union t1 t2)))
</code></pre>
<p>\caption{Type inference for simply typed lambda calculus
with matrices.
Here we require that lambda abstractions are annotated with parameter types.
Section~\ref{sec:hm} looses this restriction.}</p>
<h3 id="type-inference-beyond-simply-typed-lambda-calculus"><a class="header" href="#type-inference-beyond-simply-typed-lambda-calculus">Type Inference beyond Simply Typed Lambda Calculus</a></h3>
<p>egglog is suitable for expressing a wide range of unification-based algorithms
including equality saturation (Section~\ref{sec:eqsat}) and Steensgard analyses (Section~\ref{sec:points-to}).
In this section, we show an additional example on the expressive power of egglog:
type inference for Hindley-Milner type systems.
Unlike the simple type system presented in Section~\ref{sec:stlc},
a Hindley-Milner type system does not require type annotations for variables in lambda abstractions
and allows let-bound terms to have a \textit{scheme} of types.
For example, the term <code>let f = \x. x in (f 1, f True)</code>
is not typeable in simply typed lambda calculus,
since this requires <code>f</code> to have both type \(\textit{Int}\rightarrow\textit{Int}\)
and \(\textit{Bool}\rightarrow\textit{Bool}\).
In contrast, A Hindley-Milner type system will accept this term,
because both \(\textit{Int}\rightarrow\textit{Int}\)
and \(\textit{Bool}\rightarrow\textit{Bool}\) are instantiations of the type scheme
\(\forall \alpha,\alpha\rightarrow\alpha\).</p>
<p>Concretely,
to infer a type for the above term,
a type inference algorithm will first introduce a fresh type variable (\alpha\) for <code>x</code>,
the argument to function <code>f</code>, and infer that
the type of <code>f</code> is \(\alpha\rightarrow\alpha\).
Next, because <code>f</code> is bound in a let expression,
the algorithm generalizes the type of <code>f</code> to be a scheme by introducing forall quantified
variables, i.e., \(\forall \alpha.\alpha\rightarrow\alpha\).
At the call site of <code>f</code>,
the type scheme is instantiated by consistently substituting forall quantified type variables with fresh ones,
and the fresh type variables are later unified with concrete types.
For example, <code>f</code> in function application <code>f 1</code>
may be instantiated with type \(\alpha_1\rightarrow\alpha_1\).
Because integer <code>1</code> has type \textit{Int},
type variable \(\alpha_1\) is unified with \(\textit{Int}\),
making the occurrence of <code>f</code> here
have type \(\textit{Int}\rightarrow\textit{Int}\).
The final type of <code>f 1</code> is therefore \textit{Int}.</p>
<p>The key enabler of Hindley-Milner inference
is the ability to unify two types.
To do this,
an imperative implementation like Algorithm W \citep{hindley-milner} needs
to track the alias graphs among type variables
and potentially mutating a type variable
to link to a concrete type,
which requires careful handling.
In contrast, egglog has the right abstractions for Hindley-Milner inference
with the built-in power of unification.
The unification mechanism can be expressed as a single injectivity rule</p>
<pre><code class="language-scheme">(rule ((= (Arr fr1 to1) (Arr fr2 to2)))
      ((union fr1 fr2)
       (union to1 to2)))
</code></pre>
<p>This rule propagates unification down
from inductively defined types to their children types.
% Injective unification like this
%  is known in the literature as the dual of congruence~\citep{congr-duality}.
At unification sites,
it suffices to call <code>union</code>
on the types being unified.
For instance, calling <code>union</code> on
<code>(Arr (TVar x) (Int))</code> and <code>(Arr (Bool) (TVar y))</code>
will unify type variable \(x\) (resp.\ \(y\)) and <code>Int</code> (resp.\ <code>Bool</code>)
by putting them into the same eclass.</p>
<pre><code class="language-scheme">(function generalize (Ctx Type) Scheme)
(function instantiate (Scheme) Type)
(function lookup (Ctx Ident) Scheme)
(function typeof (Ctx Expr i64) Type)

;; Injectivity of unification
(rule ((= (Arr fr1 to1) (Arr fr2 to2)))
      ((union fr1 fr2)
       (union to1 to2)))

;; Simple types
(rewrite (typeof ctx (Num x)) (Int))
(rewrite (typeof ctx (True)) (Bool))
(rewrite (typeof ctx (False)) (Bool))
(rewrite (typeof ctx (Var x))
         (instantiate (lookup ctx x)))

;; Inferring types for lambda abstractions
(rule ((= t (typeof ctx (Abs x e))))
      ((define fresh-tv (TVar (Fresh x)))
       (define scheme (Forall (empty) fresh-tv))
       (define new-ctx (Cons x scheme ctx))
       (define t1 (typeof new-ctx e))
       (union t (Arr fresh-tv t1))))
</code></pre>
<pre><code class="language-scheme">;; Inferring types for function applcations
(rule ((= t (typeof ctx (App f e))))
	  ((define t1 (typeof ctx f))
	   (define t2 (typeof ctx e))
	   (union t1 (TArr t t2))))
;; Inferring types for let expressions
(rule ((= t (typeof ctx (Let x e1 e2))))
      ((define t1 (typeof ctx e1 c1))
       (define scheme (generalize ctx t1))
       (define new-ctx (Cons x scheme ctx))
       (define t2 (typeof new-ctx e2))
       (union t t2)))

;; Occurs check
(relation occurs-check (Ident Type))
(relation errors (Ident))
(rule ((= (TVar x) (Arr fr to)))
      ((occurs-check x fr)
       (occurs-check x to)))
(rule ((occurs-check x (Arr fr to)))
      ((occurs-check x fr)
       (occurs-check x to)))
(rule ((occurs-check x (TVar x)))
      ((errors x)
       (panic &quot;occurs check failed&quot;)))
</code></pre>
<p>\caption{Expressing Hindley-Milner inference in egglog.
<code>Ident</code> is a datatype for identifiers
that can be constructed by lifting a string or a counter (i.e., <code>i64</code>).
In the actual implementation,
we additionally track a counter in the <code>typeof</code> function
to ensure the freshness of fresh variables,
which we omit for brevity.
Definitions of <code>instantiate</code>, <code>generalize</code>,
and <code>lookup</code> are not shown as well.
}
\label{fig:hm}
\end{figure}</p>
<p>\autoref{fig:hm} shows a snippet of Hindley-Milner inference in egglog.
We translate the typing rule to rewrite rules in egglog straightforwardly.
The egglog rule for lambda abstractions says,
whenever we see a demand to check the type of <code>\x.e</code>.
We create a fresh type scheme <code>fresh-tv</code> with no variables quantified,
binding it to <code>x</code> in the context, and infer the type of body as <code>t1</code>.
Finally, we unify the type of <code>\x.e</code> with
\lstinline[mathescape=true]{fresh-tv $\rightarrow$ t1}.
%\yz{this part is different from simple type inference.}
For function application <code>f e</code>,
we can compact the two rules
for function application in simply typed lambda calculus into one rules
thanks to the injectivity rule:
we simply equate the type <code>t1</code> of <code>f</code> and the arrow type <code>Arr t t2</code>
for type <code>t</code> of <code>f e</code> and type <code>t2</code> of <code>e</code>,
and injectivity will handle the rest of unifications.
Finally, the rule for type inferring <code>let x = e1 in e2</code>
will first get and,
generalize\footnote{
Generalization, as well as instantiation for the rule for type inferring variables
is a standard operation in type inference literature.
They convert between types and type schemes based on contexts.
We omit them from the presentation for brevity.
To implement them, we also track the free type variables
for each type
in our implementation.
} the type of <code>e1</code> in the current context,
bind variable <code>x</code> to it
and infer the type of <code>e2</code> as <code>t2</code>.
The type of \lstinline[language=Haskell]{let x = e1 in e2}
is then unified with the type of <code>t2</code>.</p>
<p>In Hindley-Milner type systems,
a type variable may be accidentally unified
with a type that contains it, which results in infinitary types
like \(\alpha\rightarrow\alpha\rightarrow\ldots\) and is usually
not what users intend to do.
A Hindley-Milner inference algorithm will also
do an ``occurs check'' before
unifying a type variable with a type.
In egglog, the occurs check can be done modularly,
completely independent of the unification mechanism
and the type inference algorithm.
In \autoref{fig:hm},
we define an <code>occurs-check</code> relation
and match on cases where a type variable
is unified with an inductive type like the arrow type
and mark types that need to be occurs checked by
populating them in the <code>occurs-check</code> relation.
The occurs check fails when an <code>occurs-check</code> demand
is populated on an identifier and a type variable with the same identifier.
Our actual implementation also contains rules that
check if two different base types are unified or
a base type is unified with an arrow type,
where it will throw an error.
These could happen when two incompatible types are unified
due to ill typed terms
(e.g., when type inferring <code>True + 1</code>).</p>
<h3 id="theory-of-arrays"><a class="header" href="#theory-of-arrays">Theory of Arrays</a></h3>
<pre><code class="language-scheme">(datatype Addr (Num i64) (Var String))
(datatype Array (Const i64) (AVar String))
(function store (Array Addr Addr) Array)
(function select (Array Addr) Addr)
(function add (Addr Addr) Addr)
(relation neq (Addr Addr))
;; select gets from store
(rewrite (select (store mem i e) i) e)
;; select passes through wrong index
(rewrite (select (store mem i1 e) i2) (select mem i2)
    :when ((neq i1 i2)))
</code></pre>
<p>The theory of arrays is a simple first order axiomatization of functions that is
useful in software verification. Some of the axioms are simple rewrite rules,
but others are guarded upon no aliasing conditions of the address. Addresses may
be concrete or abstract entities. Inferring that two addresses cannot alias may
be done via constant propagation or injectivity reasoning and is a natural
application of Datalog.</p>
<p>% \rw{Is theory of arrays monotonic?}
% \pz{You're right. As written I need an explicit neq relation. I could also change to i64
% addresses, although this is a bit unsatisfying.}
% \rw{No I was just wondering, not being monotonic is fine.}
\end{comment}</p>
<h2 id="other-egglog-pearls"><a class="header" href="#other-egglog-pearls">Other Egglog Pearls</a></h2>
<p>In this subsection,
we show more self-contained programs with interesting behaviors,
further demonstrating the expressive power of egglog.</p>
<h3 id="equation-solving"><a class="header" href="#equation-solving">Equation Solving</a></h3>
<p>Many uses of eqsat and hence egglog fall into a guarded rewriting paradigm. A
different mode of use is that of equation solving: rather than
taking a left hand side and producing a right, egglog can take an entire equation
and produces a new equation.
A common manipulation in algebraic reasoning is to
manipulate equations by applying the same operation to both sides. This is often
used to isolate variables
and use one variable to substitute other variables in an equation.
Substitutions in \egraphs and egglog are implicit
(since the variable and its definition via other variables are in the same equivalence class),
and we can encode variable isolation as rules.</p>
<p>\autoref{fig:equationsolve:egglog} shows a simplistic equational system
with addition, multiplication, and negations.
Besides the standard algebraic rules,
we use two rules that manipulate equations to isolate variables.
This allows us to solve simple multivariable equations
like \[
\begin{cases}
z+y=6\
2z=y
\end{cases}
\]
.</p>
<p>Equation solving in egglog can be seen as similar to the &quot;random walk&quot; approach to
variable elimination a student may take. For specific solvable systems this may
be very inefficient compared to a dedicated algorithm.
For example one can
consider a symbolic representation of a linear algebraic system,
for which Gaussian elimination will be vastly more efficient.
However, equation solving in egglog is
compositional and
can easily handle the addition of new domain-specific rules
like those for trigonometric functions.</p>
<pre><code class="language-scheme">(datatype Expr
    (Add Expr Expr)
    (Mul Expr Expr)
    (Neg Expr)
    (Num i64)
    (Var String))

;; Algebraic rules over expressions
(rewrite (Add x y) (Add y x))
(rewrite (Add (Add x y) z) (Add x (Add y z)))
(rewrite (Add (Mul y x) (Mul z x))
         (Mul (Add y z) x))

;; Make the implicit coefficient 1 explicit
(rewrite (Var x) (Mul (Num 1) (Var x)))

;; Constant folding
(rewrite (Add (Num x) (Num y)) (Num (+ x y)))
(rewrite (Neg (Num n)) (Num (- n)))
(rewrite (Add (Neg x) x) (Num 0))

;; Variable isolation by rewriting
;; the entire equation
(rule ((= (Add x y) z))
      ((union (Add z (Neg y)) x)))
(rule ((= (Mul (Num x) y) (Num z))
       (= (% z x) 0))
      ((union (Num (/ z x)) y)))

; system 1: x + 2 = 7
(set (Add (Var &quot;x&quot;) (Num 2)) (Num 7))
; system 2: z + y = 6; 2z = y
(set (Add (Var &quot;z&quot;) (Var &quot;y&quot;)) (Num 6))
(set (Add (Var &quot;z&quot;) (Var &quot;z&quot;)) (Var &quot;y&quot;))

(run 5) ;; run 5 iterations

(extract (Var &quot;x&quot;)) ;; (Num 5)
(extract (Var &quot;y&quot;)) ;; (Num 4)
(extract (Var &quot;z&quot;)) ;; (Num 2)
</code></pre>
<h3 id="proof-datatypes"><a class="header" href="#proof-datatypes">Proof Datatypes</a></h3>
<p>Datalog proofs can be internalized as syntax trees inside of egglog. This proof
datatype has one constructor for every Datalog rule of the program and records
any intermediate information that may be necessary. This can also be done in any
Datalog system that supports terms. A unique capability of egglog however is the
ability to consider proofs of the same fact to be equivalent, a form of proof
irrelevance. This compresses the space used to store the proofs and enhances the
termination of the program which would not terminate in ordinary. In addition,
the standard extraction procedure can be used to extract a short proof.</p>
<pre><code class="language-scheme">;; Proofs of connectivity
(datatype Proof
    (Trans i64 Proof)
    (Edge i64 i64))

;; Path function points to a proof datatype
(function path (i64 i64) Proof)
(relation edge (i64 i64))

;; Base case
(rule ((edge x y))
      ((set (path x y) (Edge x y))))

;; Inductive case
(rule ((edge x y) (= p (path y z)))
      ((set (path x z) (Trans x p))))

;; Populate the graph and run
(edge 1 2)
(edge 2 3)
(edge 1 3)
(run)

;; returns the smallest proof of
;; the connectivity between 1 and 3
(extract (path 1 3))
</code></pre>
<h3 id="binary-decision-diagrams"><a class="header" href="#binary-decision-diagrams">Binary Decision Diagrams</a></h3>
<p>Binary decision diagrams are a compact canonical representation of boolean
formulas or sets of bitvectors. They can be viewed in different lights. One way
of looking at them is as a hash consed if-then-else tree
<a href="https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf">https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf</a> that examines each
variable in a prescribed order, and where any branch where the then and else
branch hold the same expression is collapsed. egglog is hash consed by it's
nature and is capable of encoding this collapse as a rewrite rule. Calculations
of functions of the BDDs is also expressible as rewrite rules, being implemented
by merging down the two trees in variable ordering.</p>
<p>This is particularly intriguing in light of the work of bddbdddb
<a href="https://bddbddb.sourceforge.net/">https://bddbddb.sourceforge.net/</a> which was a Datalog built around using binary
decision diagrams as it's core datastructure. While the egglog encoding of the
structure is unlikely going to be as efficient as a bespoke implementation, it
is capable of describing them in its surface language as a first class construct. BDDs are one form of a
first class set.</p>
<pre><code class="language-scheme">(datatype BDD
    (ITE i64 BDD BDD) ;; variables labelled by number
    (True)
    (False)
)

; compress unneeded nodes
(rewrite (ITE n a a) a)

(function and (BDD BDD) BDD)
(rewrite (and (False) n) (False))
(rewrite (and n (False)) (False))
(rewrite (and (True) x) x)
(rewrite (and x (True)) x)
; We use an order where low variables are higher in tree
; Could go the other way.
(rewrite (and (ITE n a1 a2) (ITE m b1 b2))
    (ITE n (and a1 (ITE m b1 b2)) (and a2 (ITE m b1 b2)))
    :when ((&lt; n m))
)
(rewrite (and (ITE n a1 a2) (ITE m b1 b2))
    (ITE m (and (ITE n a1 a2) b1) (and (ITE n a1 a2) b2))
    :when ((&gt; n m))
)
(rewrite (and (ITE n a1 a2) (ITE n b1 b2))
    (ITE n (and a1 b1) (and a2 b2))
)
</code></pre>
<h3 id="reasoning-about-matrices"><a class="header" href="#reasoning-about-matrices">Reasoning about matrices</a></h3>
<p>The algebra of matrices follows similar rules as the algebra of simple numbers,
except that matrix multiplication generally not commutative.
With the addition of structural operations like the Kronecker product, direct sum, and stacking of matrices a richer algebraic structure emerges.
A particularly simple and useful rewrite rule allows one to
push matrix multiplication through a Kronecker product
\((A \otimes B) \cdot (C \otimes D) = (A \cdot C) \otimes (B \cdot D)\).
Rewriting from left to right improves the asymptotic complexity of evaluating the expression.
However,
while this equation may proceed from right to left unconditionally,
the left to right application requires that the dimensionality of the matrices line up.
In a large matrix expression with possibly abstract dimensionality,
this is not easily doable in a classical equality saturation framework.
Although one may be tempted to express dimensionality
with eclass analyses,
the dimensionality is a symbolic term itself and needs to be reasoned about via algebraic rewriting.
However, the abstraction of eclass analyses do not allow rewriting over the analysis values.
On the other hand, because the analysis is just another function
not unlike the constructors for matrix expressions,
we can use standard egglog rules to reason about it
just like how we reason about matrix expressions.
\autoref{fig:matrix:egglog} shows
a simple theory of matrices with Kronecker product,
and this example can be generalized to
other (essentially) algebraic theories.</p>
<pre><code class="language-scheme">(datatype MExpr
    (MMul MExpr MExpr)
    (Kron MExpr MExpr)
    (Var String))

(datatype Dim
    (Times Dim Dim)
    (NamedDim String)
    (Lit i64))

(function nrows (MExpr) Dim)
(function ncols (MExpr) Dim)

;; Computing the dimensions of
;; matrix expressions
(rewrite (nrows (Kron A B))
         (Times (nrows A) (nrows B)))
(rewrite (ncols (Kron A B))
         (Times (ncols A) (ncols B)))
(rewrite (nrows (MMul A B)) (nrows A))
(rewrite (ncols (MMul A B)) (ncols B))

;; Reasoning about dimensionality
(rewrite (Times a (Times b c))
         (Times (Times a b) c))
(rewrite (Times (Lit i) (Lit j)) (Lit (* i j)))
(rewrite (Times a b) (Times b a))

;; Rewriting matrix multiplications and Kronecker
;; product
(rewrite (MMul A (MMul B C)) (MMul (MMul A B) C))
(rewrite (MMul (MMul A B) C) (MMul A (MMul B C)))
(rewrite (Kron A (Kron B C)) (Kron (Kron A B) C))
(rewrite (Kron (Kron A B) C) (Kron A (Kron B C)))
(rewrite (Kron (MMul A C) (MMul B D))
         (MMul (Kron A B) (Kron C D)))

;; Optimizing Kronecker product with guarded rules
(rewrite (MMul (Kron A B) (Kron C D))
         (Kron (MMul A C) (MMul B D))
    :when ((= (ncols A) (nrows C))
           (= (ncols B) (nrows D))))
</code></pre>
<p>\caption{Equality saturation with matrices in egglog.
The last rule is guarded by the equational precondition
that the dimensionalities should align,
which is made possible by
rich semantic analyses \textit{a la} Datalog.}
\label{fig:matrix:egglog}
\end{figure}</p>
<h1 id="other-examples"><a class="header" href="#other-examples">Other Examples</a></h1>
<ul>
<li>Unification</li>
<li>Bitvectors</li>
<li>Resolution theorem proving</li>
<li>Herbie</li>
<li>CClyzer</li>
<li>Gappa</li>
<li>Theorem Proving</li>
<li>Homotopy Search</li>
</ul>
<h2 id="unification"><a class="header" href="#unification">Unification</a></h2>
<p>Programmable Unification without backtracking</p>
<h2 id="bitvectors"><a class="header" href="#bitvectors">Bitvectors</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sql"><a class="header" href="#sql">SQL</a></h1>
<p>SQL at it's core is expressions of the form <code>SELECT ... FROM ... WHERE ...</code>. This makes it more query language like than programming language like. Most programming languages have a more recursive structure.</p>
<p>Extensions to SQL can do all sorts of crazy things.</p>
<ul>
<li>SQL is multiset based, datalog is set based (typically)</li>
<li>SQL gives variable names to rows, datalog gives variable names to row entries.</li>
<li>Datalog allows variables to share names defining an implicit equality constraint</li>
</ul>
<p>SQL is a useful language to perform macro operations on databases. Datalogs can be built upon a SQL interface. This isn't persay even inefficient, since the processing of the SQL text overhead will often be small compared to the manipulation of the database itself.</p>
<p>See these blog posts:</p>
<ul>
<li><a href="https://www.philipzucker.com/duckegg-post/">Duckegg: A Datalog / Egraph Implementation Built Around DuckDB</a></li>
<li><a href="https://www.philipzucker.com/datalite/">Datalite: A Simple Datalog Built Around SQLite in Python</a></li>
</ul>
<h2 id="recursive-common-tables-subexpressions"><a class="header" href="#recursive-common-tables-subexpressions">Recursive Common Tables Subexpressions</a></h2>
<p>Recursive Common Table Subexpressions enable the descrpition of an extremely limittied form of datalog.</p>
<p>Triggers might possibly be usable to do certain datalog like tasks</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementations"><a class="header" href="#implementations">Implementations</a></h1>
<ul>
<li>Flix</li>
<li>Rel</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="src/souffle.js"></script>
        <script type="text/javascript" src="src/souffle.wasm"></script>
        <script type="text/javascript" src="src/custom.js"></script>
        <script type="text/javascript" src="src/web_demo_bg.wasm"></script>
        <script type="text/javascript" src="src/web_demo.js"></script>
        <script type="text/javascript" src="src/custom_egg.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
